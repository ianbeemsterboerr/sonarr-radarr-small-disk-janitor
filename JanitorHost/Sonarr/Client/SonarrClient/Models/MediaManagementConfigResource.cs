// <auto-generated/>
#pragma warning disable CS0618
using Microsoft.Kiota.Abstractions.Extensions;
using Microsoft.Kiota.Abstractions.Serialization;
using System.Collections.Generic;
using System.IO;
using System;
namespace JanitorHost.Sonarr.Client.Models
{
    [global::System.CodeDom.Compiler.GeneratedCode("Kiota", "1.0.0")]
    #pragma warning disable CS1591
    public partial class MediaManagementConfigResource : IParsable
    #pragma warning restore CS1591
    {
        /// <summary>The autoUnmonitorPreviouslyDownloadedEpisodes property</summary>
        public bool? AutoUnmonitorPreviouslyDownloadedEpisodes { get; set; }
        /// <summary>The chmodFolder property</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public string? ChmodFolder { get; set; }
#nullable restore
#else
        public string ChmodFolder { get; set; }
#endif
        /// <summary>The chownGroup property</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public string? ChownGroup { get; set; }
#nullable restore
#else
        public string ChownGroup { get; set; }
#endif
        /// <summary>The copyUsingHardlinks property</summary>
        public bool? CopyUsingHardlinks { get; set; }
        /// <summary>The createEmptySeriesFolders property</summary>
        public bool? CreateEmptySeriesFolders { get; set; }
        /// <summary>The deleteEmptyFolders property</summary>
        public bool? DeleteEmptyFolders { get; set; }
        /// <summary>The downloadPropersAndRepacks property</summary>
        public global::JanitorHost.Sonarr.Client.Models.ProperDownloadTypes? DownloadPropersAndRepacks { get; set; }
        /// <summary>The enableMediaInfo property</summary>
        public bool? EnableMediaInfo { get; set; }
        /// <summary>The episodeTitleRequired property</summary>
        public global::JanitorHost.Sonarr.Client.Models.EpisodeTitleRequiredType? EpisodeTitleRequired { get; set; }
        /// <summary>The extraFileExtensions property</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public string? ExtraFileExtensions { get; set; }
#nullable restore
#else
        public string ExtraFileExtensions { get; set; }
#endif
        /// <summary>The fileDate property</summary>
        public global::JanitorHost.Sonarr.Client.Models.FileDateType? FileDate { get; set; }
        /// <summary>The id property</summary>
        public int? Id { get; set; }
        /// <summary>The importExtraFiles property</summary>
        public bool? ImportExtraFiles { get; set; }
        /// <summary>The minimumFreeSpaceWhenImporting property</summary>
        public int? MinimumFreeSpaceWhenImporting { get; set; }
        /// <summary>The recycleBin property</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public string? RecycleBin { get; set; }
#nullable restore
#else
        public string RecycleBin { get; set; }
#endif
        /// <summary>The recycleBinCleanupDays property</summary>
        public int? RecycleBinCleanupDays { get; set; }
        /// <summary>The rescanAfterRefresh property</summary>
        public global::JanitorHost.Sonarr.Client.Models.RescanAfterRefreshType? RescanAfterRefresh { get; set; }
        /// <summary>The scriptImportPath property</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public string? ScriptImportPath { get; set; }
#nullable restore
#else
        public string ScriptImportPath { get; set; }
#endif
        /// <summary>The setPermissionsLinux property</summary>
        public bool? SetPermissionsLinux { get; set; }
        /// <summary>The skipFreeSpaceCheckWhenImporting property</summary>
        public bool? SkipFreeSpaceCheckWhenImporting { get; set; }
        /// <summary>The useScriptImport property</summary>
        public bool? UseScriptImport { get; set; }
        /// <summary>
        /// Creates a new instance of the appropriate class based on discriminator value
        /// </summary>
        /// <returns>A <see cref="global::JanitorHost.Sonarr.Client.Models.MediaManagementConfigResource"/></returns>
        /// <param name="parseNode">The parse node to use to read the discriminator value and create the object</param>
        public static global::JanitorHost.Sonarr.Client.Models.MediaManagementConfigResource CreateFromDiscriminatorValue(IParseNode parseNode)
        {
            if(ReferenceEquals(parseNode, null)) throw new ArgumentNullException(nameof(parseNode));
            return new global::JanitorHost.Sonarr.Client.Models.MediaManagementConfigResource();
        }
        /// <summary>
        /// The deserialization information for the current model
        /// </summary>
        /// <returns>A IDictionary&lt;string, Action&lt;IParseNode&gt;&gt;</returns>
        public virtual IDictionary<string, Action<IParseNode>> GetFieldDeserializers()
        {
            return new Dictionary<string, Action<IParseNode>>
            {
                { "autoUnmonitorPreviouslyDownloadedEpisodes", n => { AutoUnmonitorPreviouslyDownloadedEpisodes = n.GetBoolValue(); } },
                { "chmodFolder", n => { ChmodFolder = n.GetStringValue(); } },
                { "chownGroup", n => { ChownGroup = n.GetStringValue(); } },
                { "copyUsingHardlinks", n => { CopyUsingHardlinks = n.GetBoolValue(); } },
                { "createEmptySeriesFolders", n => { CreateEmptySeriesFolders = n.GetBoolValue(); } },
                { "deleteEmptyFolders", n => { DeleteEmptyFolders = n.GetBoolValue(); } },
                { "downloadPropersAndRepacks", n => { DownloadPropersAndRepacks = n.GetEnumValue<global::JanitorHost.Sonarr.Client.Models.ProperDownloadTypes>(); } },
                { "enableMediaInfo", n => { EnableMediaInfo = n.GetBoolValue(); } },
                { "episodeTitleRequired", n => { EpisodeTitleRequired = n.GetEnumValue<global::JanitorHost.Sonarr.Client.Models.EpisodeTitleRequiredType>(); } },
                { "extraFileExtensions", n => { ExtraFileExtensions = n.GetStringValue(); } },
                { "fileDate", n => { FileDate = n.GetEnumValue<global::JanitorHost.Sonarr.Client.Models.FileDateType>(); } },
                { "id", n => { Id = n.GetIntValue(); } },
                { "importExtraFiles", n => { ImportExtraFiles = n.GetBoolValue(); } },
                { "minimumFreeSpaceWhenImporting", n => { MinimumFreeSpaceWhenImporting = n.GetIntValue(); } },
                { "recycleBin", n => { RecycleBin = n.GetStringValue(); } },
                { "recycleBinCleanupDays", n => { RecycleBinCleanupDays = n.GetIntValue(); } },
                { "rescanAfterRefresh", n => { RescanAfterRefresh = n.GetEnumValue<global::JanitorHost.Sonarr.Client.Models.RescanAfterRefreshType>(); } },
                { "scriptImportPath", n => { ScriptImportPath = n.GetStringValue(); } },
                { "setPermissionsLinux", n => { SetPermissionsLinux = n.GetBoolValue(); } },
                { "skipFreeSpaceCheckWhenImporting", n => { SkipFreeSpaceCheckWhenImporting = n.GetBoolValue(); } },
                { "useScriptImport", n => { UseScriptImport = n.GetBoolValue(); } },
            };
        }
        /// <summary>
        /// Serializes information the current object
        /// </summary>
        /// <param name="writer">Serialization writer to use to serialize this model</param>
        public virtual void Serialize(ISerializationWriter writer)
        {
            if(ReferenceEquals(writer, null)) throw new ArgumentNullException(nameof(writer));
            writer.WriteBoolValue("autoUnmonitorPreviouslyDownloadedEpisodes", AutoUnmonitorPreviouslyDownloadedEpisodes);
            writer.WriteStringValue("chmodFolder", ChmodFolder);
            writer.WriteStringValue("chownGroup", ChownGroup);
            writer.WriteBoolValue("copyUsingHardlinks", CopyUsingHardlinks);
            writer.WriteBoolValue("createEmptySeriesFolders", CreateEmptySeriesFolders);
            writer.WriteBoolValue("deleteEmptyFolders", DeleteEmptyFolders);
            writer.WriteEnumValue<global::JanitorHost.Sonarr.Client.Models.ProperDownloadTypes>("downloadPropersAndRepacks", DownloadPropersAndRepacks);
            writer.WriteBoolValue("enableMediaInfo", EnableMediaInfo);
            writer.WriteEnumValue<global::JanitorHost.Sonarr.Client.Models.EpisodeTitleRequiredType>("episodeTitleRequired", EpisodeTitleRequired);
            writer.WriteStringValue("extraFileExtensions", ExtraFileExtensions);
            writer.WriteEnumValue<global::JanitorHost.Sonarr.Client.Models.FileDateType>("fileDate", FileDate);
            writer.WriteIntValue("id", Id);
            writer.WriteBoolValue("importExtraFiles", ImportExtraFiles);
            writer.WriteIntValue("minimumFreeSpaceWhenImporting", MinimumFreeSpaceWhenImporting);
            writer.WriteStringValue("recycleBin", RecycleBin);
            writer.WriteIntValue("recycleBinCleanupDays", RecycleBinCleanupDays);
            writer.WriteEnumValue<global::JanitorHost.Sonarr.Client.Models.RescanAfterRefreshType>("rescanAfterRefresh", RescanAfterRefresh);
            writer.WriteStringValue("scriptImportPath", ScriptImportPath);
            writer.WriteBoolValue("setPermissionsLinux", SetPermissionsLinux);
            writer.WriteBoolValue("skipFreeSpaceCheckWhenImporting", SkipFreeSpaceCheckWhenImporting);
            writer.WriteBoolValue("useScriptImport", UseScriptImport);
        }
    }
}
#pragma warning restore CS0618
